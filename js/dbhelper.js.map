{"version":3,"sources":["dbhelper.js"],"names":["DBHelper","callback","xhr","XMLHttpRequest","open","DATABASE_URL","onload","status","restaurants","JSON","parse","responseText","error","concat","send","id","fetchRestaurants","restaurant","find","r","results","filter","cuisine_type","cuisine","neighborhood","neighborhoods","map","v","i","uniqueNeighborhoods","indexOf","cuisines","uniqueCuisines","photograph","position","latlng","name","url","urlForRestaurant","animation","google","maps","Animation","DROP"],"mappings":"uZAGMA,4HAcoBC,GACtB,IAAIC,EAAM,IAAIC,eACdD,EAAIE,KAAK,MAAOJ,EAASK,cACzBH,EAAII,OAAS,WANf,GAAA,MAAAJ,EAAAK,OAAA,CAQM,IACMC,EADOC,KAAKC,MAAMR,EAAIS,cACHH,YACzBP,EAAS,KAAMO,OANZ,CACPN,IAAAU,EAAS,sCAAAC,OAATX,EAAAK,QAQIN,EAASW,EAAO,QANQV,EAAAY,mDAKbC,EAAAd,GAEZD,EAAAgB,iBAAA,SAAAJ,EAAAJ,GACF,GATDI,EAoBIX,EAASW,EAAO,UAVhBE,CACL,IAAAG,EAAAT,EAAAU,KAAA,SAAAC,GAAA,OAAAA,EAAAJ,IAAAA,IAEDE,EAWQhB,EAAS,KAAMgB,GAEfhB,EAAS,4BAA6B,0DAJrBO,EAAAP,GAAkBD,EAArCgB,iBAAA,SAAAJ,EAAAJ,GAgBF,GAAII,EAfFX,EAAIgB,EAAJ,UAAkB,CAEjB,IAFDG,EAEOZ,EAAAa,OAAA,SAAAF,GAAA,OAAAA,EAAAG,cAAAC,IAAEtB,EAAA,KAAAmB,4DA0BsBI,EAAcvB,GAEjDD,EAASgB,iBAAiB,SAACJ,EAAOJ,GAChC,GAAII,EACFX,EAASW,EAAO,UAnBpB,CAEE,IAAIA,EAAOJ,EAAAa,OAAA,SAAAF,GAAA,OAAAA,EAAAK,cAAAA,IACTvB,EAAAA,KAASW,sEAFbW,EAAAC,EAAAvB,GAWFD,EAAAgB,iBAAA,SAAAJ,EAAAJ,GAsBI,GAAII,EACFX,EAASW,EAAO,UACX,CACL,IAAIQ,EAAUZ,EACC,OAAXe,IACFH,EAAUA,EAAQC,OAAO,SAAAF,GAAC,OAAIA,EAAEG,cAxBHE,KAE1BR,OAAThB,IACEoB,EAAWA,EAAAC,OAAA,SAAAF,GAAA,OAAAA,EAAAK,cAAAA,KAEVvB,EAAM,KAAAmB,iDAMVnB,GA4BCD,EAASgB,iBAAiB,SAACJ,EAAOJ,GAChC,GAAII,EACFX,EAASW,EAAO,UACX,CAEL,IAAMa,EAAgBjB,EAAYkB,IAAI,SAACC,EAAGC,GAAJ,OAAUpB,EAAYoB,GA5BVJ,eAE9CK,EAAkBJ,EAAQjB,OAAAA,SAAAA,EAARoB,GAAQpB,OAAgBiB,EAAAK,QAAAH,IAAAC,IAChD3B,EAAA,KAAW4B,4CAKyBP,GACjCtB,EAAAgB,iBAAA,SAAAJ,EAAAJ,GAiCH,GAAII,EAhCFX,EAAIuB,EAAAA,UAAyB,CACD,IAAAO,EAAMP,EAAFE,IAAkBF,SAAAA,EAAAA,GAAAA,OAAtBhB,EAAAoB,GAAAN,eAC3BU,EAAAD,EAAAV,OAAA,SAAAM,EAAAC,GAAA,OAAAG,EAAAD,QAAAH,IAAAC,IAqCD3B,EAAS,KAAM+B,+CAQGf,GACtB,MAAA,wBAAAJ,OAAgCI,EAAWF,kDAjCvCE,GACD,MAAA,QAAAJ,OAAMI,EAAAgB,2DAICJ,EAAsBJ,GAiDhC,OAjD+DA,IAAAA,OAAAA,KAAcK,OAAd,CAAVI,SAAjDjB,EAAAkB,OACAlC,MAAAA,EAAQmC,KACTC,IAAArC,EAAAsC,iBAAArB,GACFS,IAVDA,EAWDa,UAAAC,OAAAC,KAAAC,UAAAC,4CAtHG3C,MAAAA,oBAAAA,OAOW,KAPXA","file":"dbhelper.js","sourcesContent":["/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n  /**\r\n   * Database URL.\r\n   * Change this to restaurants.json file location on your server.\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 3002 // Change this to your server port\r\n    return `http://localhost:${port}/data/restaurants.json`;\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open('GET', DBHelper.DATABASE_URL);\r\n    xhr.onload = () => {\r\n      if (xhr.status === 200) { // Got a success response from server!\r\n        const json = JSON.parse(xhr.responseText);\r\n        const restaurants = json.restaurants;\r\n        callback(null, restaurants);\r\n      } else { // Oops!. Got an error from server.\r\n        const error = (`Request failed. Returned status of ${xhr.status}`);\r\n        callback(error, null);\r\n      }\r\n    };\r\n    xhr.send();\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // filter by cuisine\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // filter by neighborhood\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant) {\r\n    return (`/img/${restaurant.photograph}`);\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  }\r\n\r\n}\r\n"]}